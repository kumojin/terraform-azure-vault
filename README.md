# Vault HA Cluster

This describes how to deploy a Vault HA cluster.

## Prerequisites

### System

The [Terraform](https://www.terraform.io/) application must be installed on the system, as well as the [Azure CLI](https://docs.microsoft.com/en-us/cli/azure/).

### Azure

Some resources in [Azure](https://azure.microsoft.com/en-us/) are required: an Azure [subscription](https://portal.azure.com/#blade/Microsoft_Azure_Billing/SubscriptionsBlade), and a [registered application](https://portal.azure.com/#blade/Microsoft_AAD_RegisteredApps/ApplicationsListBlade). Both should be under the same Active Directory tenant.

Some [virtual machine images](https://portal.azure.com/#blade/HubsExtension/BrowseResource/resourceType/Microsoft.Compute%2Fimages) are also required: one containing the Vault application, and another with an nginx server and the certbot service. More information about creating them can be found in the [`packer-vault`](packer-vault/README.md) and [`packer-nginx`](packer-nginx/README.md) folders, respectively.

## Deployment with Terraform

### Initializing

From the repository's main folder, Terraform's [`init`](https://www.terraform.io/docs/cli/commands/init.html) command will prepare the configuration:

```bash
terraform init
```

### Planning

A [`plan`](https://www.terraform.io/docs/cli/commands/plan.html) can then be created.

The following variables are required:

* `azure_tenant_id`: the Azure tenant under which the subscription and application are located
* `azure_subscription_id`: the subscription where the Vault cluster is to be deployed
* `azure_client_id`: the application's service principal with necessary permissions for the deployment
* `azure_client_secret`: the service principal's secret password
* `vault_source_image_id`: the virtual machine image set to run the `vault` service
* `nginx_source_image_id`: the virtual machine image containing `nginx` and `certbot`
* `cert_domain_name`: the domain name where the application will be reachable.

The following example saves the plan into the `vault.pln` file:

```bash
terraform plan \
  -var azure_tenant_id=d2e32f1f-2b06-4170-8082-e44928f950df \
  -var azure_subscription_id=be45123f-2769-4b5a-a7d1-5d3772b11a8b \
  -var azure_client_id=747a4502-4be3-4619-9936-717683af7592 \
  -var azure_client_secret=secret \
  -var vault_source_image_id=/subscriptions/be45123f-2769-4b5a-a7d1-5d3772b11a8b/resourceGroups/my-resource-group/providers/Microsoft.Compute/images/vault-image \
  -var nginx_source_image_id=/subscriptions/be45123f-2769-4b5a-a7d1-5d3772b11a8b/resourceGroups/my-resource-group/providers/Microsoft.Compute/images/nginx-image \
  -var cert_domain_name=example.com \
  -out vault.pln
```

### Deploying

With the deployment planned, Terraform's [`apply`](https://www.terraform.io/docs/cli/commands/apply.html) command will trigger the deployment:

```bash
terraform apply vault.pln
```

## Post-Deployment

There are some things that need to be done after the Terraform deployment.

The output will contain, among some other things, the IP addresses of the Nginx VM and the Vault Load Balancer.

### Generate TLS Certificate

The first step is to create a DNS A record for the domain name, pointing to the nginx VM's public IP address.

Note: If this domain already exists and only changed the IP address, it may take some time to propagate through DNS servers, depending on the record's TTL.

The certificate can be generated by SSH'ing into the nginx VM

```bash
ssh vm-user@$(terraform output -raw nginx_ip_addr)
```

and executing the `certbot` service, substituting the domain name and email address

```bash
export CERT_DOMAIN_NAME=example.com
export CERT_EMAIL_ADDRESS=email@example.com
sudo certbot run --non-interactive --nginx --domains ${CERT_DOMAIN_NAME} --email ${CERT_EMAIL_ADDRESS} --agree-tos
```

This will generate the public certificate and private key into the `/etc/letsencrypt/live/example.com/` folder, and modify `/etc/nginx/sites-available/default` to use them. The email address will be associated to the certificate and be used by Let's Encrypt for important notifications.

At this point, `certbot` should already be set up in a cron job to periodically renew its certificates. The following lists the current system timers (a timer should be present for certbot, eg. `certbot.timer` or `snap.certbot.renew.timer`) and tests whether a certificate renewal could cause problems:

```bash
systemctl list-timers --all
sudo certbot renew --dry-run
```

The SSH session can be closed.

### Initializing the Vault Cluster

All Vault instances are currently non-initialized and sealed. One of the instances should be initialized, which will unseal it. The other instances will automatically join, form a cluster, and unseal.

Since the VM in front of the Vault cluster is now TLS-protected, the certificate's domain name must be used instead of its IP address. The following initializes one of the Vault instances ("randomly" through the load balancer).

```bash
export DOMAIN_NAME="example.com"

curl https://${DOMAIN_NAME}:8200/v1/sys/init \
  --request PUT \
  --header 'Content-Type:application/json' \
  --data '{"recovery_shares":5,"recovery_threshold":3}'
```

The response will contain a root token and a set of recovery keys. The root token is used for administrative actions, while the recovery keys should ideally be encrypted and stored separately by different people.

### Configuring Vault

At the very least, a [secret engine](https://www.vaultproject.io/docs/secrets) and [authentication method](https://www.vaultproject.io/docs/auth) must be configured. Policies must be created to allow applications to generate credentials, etc.

The Vault UI can be accessed via a browser at `${DOMAIN_NAME}:8200`, using the root token to login. The UI will help configuring the initial resources.

There are a lot of documentation and tutorials about this. For example, Azure can be used to handle Vault's backend - see [secret engine](https://www.vaultproject.io/api/secret/azure), [authentication](https://www.vaultproject.io/api/auth/azure), and [secret management](https://learn.hashicorp.com/tutorials/vault/azure-secrets).

### Strengthening for Production

Some best practices for production deployments should then be considered.

More information can be found in Hashicorp's [Production Hardening](https://learn.hashicorp.com/tutorials/vault/production-hardening) tutorial.

#### Revoking the Root Token

After the initial configuration, it is a good idea to minimize the risk of exposure by revoking the root token.

```bash
curl --request POST http://${DOMAIN_NAME}:8200/v1/auth/token/revoke-self --header "X-Vault-Token: ${ROOT_TOKEN}"
```

If needed, the root token can be regenerated, but this requires the recovery keys. Steps can be followed using the [CLI](https://learn.hashicorp.com/tutorials/vault/generate-root) or [API](https://www.vaultproject.io/api-docs/system/generate-root).

#### Disabling SSH Access

The deployment left all VMs' SSH ports open for convenience during deployment. They are a frequent point of attack and should be disabled in Azure Portal.

When everything works correctly, both `vault-nsg` and `nginx-nsg` have inbound security rules named `ssh` that can be deleted. They can be created anew when needed.

### Debugging

If something goes wrong, SSH access to one of the VM might be necessary. The Nginx VM can be accessed through the domain name, port 22, while the Vault instance VMs can be reached via the IP address and port that an be found in the Load Balancer `vault-lb`, under the Inbound NAT Rules section. For example:

```bash
ssh vm-user@example.com
ssh vm-user@93.184.216.34 -p 50001
```

#### Debugging the Vault Cluster

From inside the VM, the Vault API can be reached at the `127.0.0.1:8200` host.

The current Vault instance's configuration file can be found at `/etc/vault.d/vault.hcl`.

Some useful commands:

* `sudo journalctl --unit=vault` will print the Vault service's log
* `vault status` will print the current instance's status
* `vault login ${ROOT_TOKEN}` logins into the Vault instance and allows administrative actions
* `vault operator raft list-peers` lists all Vault instances in the current cluster
* `vault operator raft autopilot state` lists information about the cluster's Vault instances and their health
* `curl http://127.0.0.1:8200/v1/sys/health` shows the health of the current instance
* `curl http://127.0.0.1:8200/v1/sys/seal-status` shows the initialization and seal status of the instance
* `curl http://127.0.0.1:8200/v1/sys/leader` shows information about the current cluster leader
* `curl http://169.254.169.254/metadata/instance?api-version=2020-09-01 -H 'Metadata:true' | jq` will show information about the virtual machine
